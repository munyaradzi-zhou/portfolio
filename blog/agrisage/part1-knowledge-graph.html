<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Building AgriSage: Graph-Based Knowledge Retrieval for Agriculture (Part 1) — AgriSage Blog — Munyaradzi Comfort Zhou</title>
  <link rel="stylesheet" href="../../css/variables.css">
  <link rel="stylesheet" href="../../css/main.css">
</head>
<body>
  <nav class="nav">
    <div class="nav-inner">
      <a href="../../index.html" class="nav-brand">MCZ</a>
      <button class="nav-toggle" aria-label="Toggle navigation">
        <span></span><span></span><span></span>
      </button>
      <ul class="nav-links">
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../../projects.html">Projects</a></li>
        <li><a href="../../blogs.html">Blog</a></li>
        <li><a href="../../cv.html">CV</a></li>
      </ul>
    </div>
  </nav>
  <main class="container">
    <article>
      <div class="post-header">
        <h1>Building AgriSage: Graph-Based Knowledge Retrieval for Agriculture (Part 1)</h1>
        <p class="meta">AgriSage Series &middot; Part 1 of 3</p>
      </div>
      <div class="post-content">

        <p><em>This is Part 1 of a 3-part series on building AgriSage, a graph-native RAG system for agricultural knowledge retrieval. <a href="part2-rag-pipeline.html">Part 2</a> covers the RAG pipeline and retrieval strategy. <a href="part3-conversational.html">Part 3</a> covers the conversational interface and evaluation.</em></p>

        <hr>

        <h2>Introduction</h2>

        <p>Imagine a farmer asks: "What is the recommended dosage for copper fungicide to treat late blight on tomatoes during flowering?" That sounds like a single question. But the answer isn't sitting in one paragraph somewhere. It lives across a chain of connected facts: the crop (tomato) is <em>susceptible to</em> a disease (late blight), which is <em>treated by</em> a chemical (copper fungicide), which <em>has parameters</em> (dosage: 1.5-3.0 kg/ha), and the crop <em>has a growth stage</em> (flowering) that <em>requires treatment</em> (copper fungicide). That chain spans four hops across five entity types.</p>

        <p>Here's the thing about vector search &mdash; the default retrieval approach in most RAG systems. It works by embedding text chunks as dense vectors and finding the top-k most similar ones. Think of it like Googling by vibe: you describe what you're looking for and it finds things that feel close. For simple, single-hop questions, that's totally fine. But for multi-hop reasoning over structured relationships, it falls apart. You might get the dosage from one chunk, the disease name from another, and the growth stage from a third &mdash; with no guarantee they're all talking about the same treatment protocol.</p>

        <p>AgriSage was built to solve this. It uses <strong>graph-native RAG</strong> for agricultural knowledge: storing entities and their relationships in a Neo4j knowledge graph, then retrieving answers through explicit graph traversal rather than vector similarity. The core idea is simple &mdash; when your data has structure, your retrieval should actually use that structure.</p>

        <hr>

        <h2>Why Graph-Native Retrieval Matters for Agriculture</h2>

        <p>Agricultural knowledge is inherently relational. Consider the kinds of questions a farmer or agronomist actually asks:</p>

        <table>
          <thead>
            <tr>
              <th>Question Type</th>
              <th>Required Reasoning Path</th>
              <th>Hops</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>"What pests affect tomatoes?"</td>
              <td>Crop -&gt; Pest</td>
              <td>1</td>
            </tr>
            <tr>
              <td>"What treatments exist for late blight?"</td>
              <td>Disease -&gt; Treatment</td>
              <td>1</td>
            </tr>
            <tr>
              <td>"How do I treat late blight on tomatoes?"</td>
              <td>Crop -&gt; Disease -&gt; Treatment</td>
              <td>2</td>
            </tr>
            <tr>
              <td>"What is the dosage for treating late blight on tomatoes?"</td>
              <td>Crop -&gt; Disease -&gt; Treatment -&gt; Parameter</td>
              <td>3</td>
            </tr>
            <tr>
              <td>"What treatments should I apply to tomatoes during flowering?"</td>
              <td>Crop -&gt; GrowthStage -&gt; Treatment -&gt; Parameter</td>
              <td>3</td>
            </tr>
          </tbody>
        </table>

        <p>Single-hop questions work great with vector search: embed the question, find the closest chunk, pull out the answer. But the questions farmers actually ask in practice are almost always multi-hop (2-4 hops). They want actionable advice that combines crop identity, threat identification, treatment selection, and dosage parameters all in one coherent answer.</p>

        <p>A knowledge graph encodes these relationships explicitly. Think of it like a giant spider web where each dot is a fact and the threads are how those facts connect to each other. Instead of hoping the right chunks happen to land near each other in embedding space, we can walk a precise path from crop to disease to treatment to dosage. The graph guarantees that the relationships we follow are real &mdash; not inferred by vector proximity or hallucinated by an LLM.</p>

        <hr>

        <h2>System Architecture</h2>

        <p>The following diagram shows the end-to-end architecture of AgriSage, from document ingestion to query response:</p>

        <p>The architecture has four major subsystems:</p>

        <ol>
          <li><strong>Ingestion Pipeline</strong>: Loads agricultural documents, chunks them intelligently, extracts entities and relationships, and builds the knowledge graph.</li>
          <li><strong>Dual Storage</strong>: Neo4j for structured graph data (primary) and ChromaDB for vector embeddings (fallback).</li>
          <li><strong>Query Pipeline</strong>: Decomposes complex questions, generates Cypher queries, retrieves from the graph, and falls back to vector search when needed.</li>
          <li><strong>Conversational Interface</strong>: Manages multi-turn sessions and serves responses through FastAPI and Streamlit.</li>
        </ol>

        <hr>

        <h2>Knowledge Graph Schema Design</h2>

        <p>The schema is basically the rulebook for the whole system. Get this wrong and everything downstream falls apart. Get it right and the thing practically answers questions by itself. So let's talk through why I designed it the way I did.</p>

        <p>The schema is defined in Python using enums and dataclasses, which keeps it in one place and makes it available to every component in the system:</p>

<pre><code class="language-python">class NodeLabel(str, Enum):
    CROP = "Crop"
    PEST = "Pest"
    DISEASE = "Disease"
    TREATMENT = "Treatment"
    GROWTH_STAGE = "GrowthStage"
    PARAMETER = "Parameter"
    DOCUMENT = "Document"

class RelationType(str, Enum):
    SUSCEPTIBLE_TO = "SUSCEPTIBLE_TO"
    TREATED_BY = "TREATED_BY"
    HAS_PARAMETER = "HAS_PARAMETER"
    HAS_STAGE = "HAS_STAGE"
    REQUIRES_TREATMENT = "REQUIRES_TREATMENT"
    DESCRIBES = "DESCRIBES"
    CONTRAINDICATED_WITH = "CONTRAINDICATED_WITH"</code></pre>

        <h3>Design Rationale</h3>

        <p>Several deliberate choices shaped this schema:</p>

        <p><strong>Separating Pest and Disease nodes.</strong> Both are "threats" to crops, but they're fundamentally different things &mdash; insects versus fungal pathogens, insecticides versus fungicides, completely different monitoring strategies. Keeping them as distinct node types means Cypher queries can target specific threat categories without filtering on a type property every time.</p>

        <p><strong>Parameters get their own nodes &mdash; and this matters more than it sounds.</strong> A dosage isn't just a property of a treatment. The same treatment has <em>different</em> dosages depending on which crop you're spraying, what growth stage it's in, and which country's regulations you're following. If you bake the dosage directly into the treatment node, you lose all that nuance. Give it its own node and suddenly you can ask really specific questions about it &mdash; and actually get the right answer.</p>

        <p><strong>Growth stages linked to treatments.</strong> The <code>REQUIRES_TREATMENT</code> relationship between <code>GrowthStage</code> and <code>Treatment</code> captures the temporal dimension of crop protection: certain treatments are only appropriate during specific growth phases. This is what lets you answer "When should I apply copper fungicide to tomatoes?" through direct graph traversal rather than hoping a relevant paragraph shows up in a vector search.</p>

        <p><strong>Document provenance.</strong> Every entity can be traced back to its source via <code>DESCRIBES</code> relationships from <code>Document</code> nodes. This supports source citations in responses and lets users verify where the information AgriSage provides actually came from. Trust but verify &mdash; especially when you're giving farming advice.</p>

        <p><strong>Contraindication modeling.</strong> The <code>CONTRAINDICATED_WITH</code> relationship between treatments captures chemical incompatibilities. This is critical safety information, and it would be extremely difficult to retrieve reliably through vector search alone. Having it explicitly in the graph means it's never missed.</p>

        <hr>

        <h2>Document Ingestion Pipeline</h2>

        <p>The ingestion pipeline transforms unstructured agricultural documents into the structured knowledge graph. It runs through four stages.</p>

        <h3>Stage 1: Document Loading</h3>

        <p>The <code>DocumentLoader</code> supports PDF, Markdown, plain text, and DOCX formats. It recursively scans a directory and loads each supported file with its metadata:</p>

<pre><code class="language-python">class DocumentLoader:
    SUPPORTED = {".txt", ".md", ".pdf", ".docx"}

    def load_directory(self, path: str | Path) -&gt; list[Document]:
        path = Path(path)
        docs: list[Document] = []
        for file_path in sorted(path.rglob("*")):
            if file_path.suffix.lower() in self.SUPPORTED:
                doc = self.load_file(file_path)
                docs.append(doc)
        return docs</code></pre>

        <p>Each loaded document carries metadata (filename, format, file size) and the full text content, packaged in a <code>Document</code> dataclass.</p>

        <h3>Stage 2: Section-Aware Chunking</h3>

        <p>Raw text is split into chunks using a section-aware strategy. The <code>DocumentChunker</code> first splits on markdown headers to preserve section boundaries, then subdivides oversized sections into overlapping chunks that break at sentence boundaries:</p>

<pre><code class="language-python">class DocumentChunker:
    def __init__(self, chunk_size: int = 800, chunk_overlap: int = 100):
        self.chunk_size = chunk_size
        self.chunk_overlap = chunk_overlap

    def chunk_by_sections(self, text: str, source: str = "") -&gt; list[Chunk]:
        sections = re.split(r"\n(?=#{1,3}\s)", text)
        chunks: list[Chunk] = []
        for section in sections:
            if len(section) &lt;= self.chunk_size:
                chunks.append(Chunk(section, len(chunks), source, ...))
            else:
                sub_chunks = self.chunk_by_size(section, source)
                chunks.extend(sub_chunks)
        return chunks</code></pre>

        <p>The 800-token chunk size and 100-token overlap balance two competing needs: larger chunks give more context for entity extraction, smaller chunks reduce noise. Section-aware splitting is important because it keeps related content together &mdash; a chunk about "Late Blight Treatment" shouldn't bleed into a section about "Powdery Mildew Prevention."</p>

        <h3>Stage 3: Entity Extraction</h3>

        <p>Each chunk passes through a dual extraction strategy: LLM-based extraction when available, with regex-based fallback. The LLM extractor prompts a model to return structured JSON with crops, pests, diseases, treatments, parameters, and relationships. The regex extractor matches against curated lists of known agricultural entities:</p>

<pre><code class="language-python">KNOWN_DISEASES = [
    "late blight", "powdery mildew", "downy mildew", "fusarium wilt",
    "botrytis", "gray mold", "rice blast", "corn smut", "apple scab",
    "bacterial wilt", "rust", "anthracnose", "root rot", "leaf spot",
]

def extract_entities_regex(text: str) -&gt; dict[str, list[str]]:
    text_lower = text.lower()
    entities = {"crops": [], "pests": [], "diseases": [], "treatments": []}
    for disease in KNOWN_DISEASES:
        if disease in text_lower:
            entities["diseases"].append(disease.title())
    return entities</code></pre>

        <p>A separate <code>extract_parameters_from_text</code> function uses specialized regex patterns to pull out dosages, application intervals, and pre-harvest intervals &mdash; the quantitative details that make agricultural advice actually actionable.</p>

        <h3>Stage 4: Graph Building</h3>

        <p>The <code>GraphBuilder</code> orchestrates the full pipeline and loads extracted entities into Neo4j. It processes each document by chunking, extracting entities from each chunk, and creating the corresponding nodes and relationships:</p>

<pre><code class="language-python">class GraphBuilder:
    def process_document(self, document: Document) -&gt; dict[str, int]:
        chunks = self.chunker.chunk_by_sections(document.content, source=document.source_path)
        self.loader.load_document({"title": document.metadata.get("filename", "Unknown"), ...})

        for chunk in chunks:
            entities = extract_entities_llm(chunk.text, self.llm_client)
            for crop_name in entities.get("crops", []):
                self.loader.load_crop({"name": crop_name})
            for pest_name in entities.get("pests", []):
                self.loader.load_pest(
                    {"name": pest_name, "type": "insect", "severity": "medium"},
                    affected_crops=entities.get("crops", []),
                )
            # ... diseases, treatments, parameters
        return counts</code></pre>

        <p>The loader uses <code>MERGE</code> operations in Neo4j, so duplicate entities from overlapping chunks get deduplicated rather than copied. Relationships are created between co-occurring entities within the same chunk, capturing the implicit connections in the source text.</p>

        <hr>

        <h2>What's Next</h2>

        <p>In <a href="part2-rag-pipeline.html">Part 2</a>, we dive into the core of the system: how AgriSage decomposes complex agricultural questions using the ReAct pattern, generates schema-aware Cypher queries with domain-specific few-shot examples, and combines graph-native and vector retrieval into a hybrid strategy. We'll walk through concrete code examples showing the full pipeline from natural language question to structured graph traversal.</p>

      </div>
      <div class="post-nav">
        <a href="../../blogs.html">&larr; Back to Blog</a>
        <a href="part2-rag-pipeline.html">Part 2: RAG Pipeline &amp; Retrieval &rarr;</a>
      </div>
    </article>
  </main>
  <footer class="footer">
    <div class="container">
      <p>&copy; 2026 Munyaradzi Comfort Zhou. Built with intention.</p>
    </div>
  </footer>
  <script src="../../js/main.js"></script>
</body>
</html>
